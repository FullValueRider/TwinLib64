' VERSION 1.0 CLASS
' BEGIN
'   MultiUse = -1  'True
' End
' Attribute VB_Name = "Kvp"
' Attribute VB_GlobalNameSpace = False
' Attribute VB_Creatable = False
' Attribute VB_PredeclaredId = True
' Attribute VB_Exposed = True
' Attribute VB_Description = "Kvp is a flexible Key/Value pair dictionary targeted at VB/VBA. It facilitates data input, direct content manipulation of items and keys, and indirect manipulation of data via Map and Comparer objects"
' '@IgnoreModule IndexedDefaultMemberAccess
' '@IgnoreModule
' Option Explicit
' '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' ' Code line limit should be 120 characters.
' ' Comment line limit should be 80 characters
' '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' '
' '
' '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' '@PredeclaredId
' '@Exposed
' '@Folder("VBALib")
' '@ModuleDescription("Kvp is a flexible Key/Value pair dictionary targeted at VB/VBA. It facilitates data input, direct content manipulation of items and keys, and indirect manipulation of data via Map and Comparer objects")
    
'     Public Enum IndexSelector
        
'         IsIndex
'         IsKey
        
'     End Enum
    
'     Public Enum RemoveType
        
'         AsArray
'         AsLyst
'         AsKvp
        
'     End Enum
    
'     Private Type InternalConstants
    
    
'         Location                                    As String
'         DefaultSeparator                            As String 'char.comma
'         DefaultAdjustAmount                         As Long
'         ClassName                                   As String
'         CountIsInvalid                              As Long ' -1
'         'Const i.KvpError                           As Long = 17 + vbObjectError
'         'Const i.ParamArrayIsEmpty                  As Long = -1
'         'Const OptionalDefault                      As Long = -1
'         FlagAddItems                                As Long '-1

'     End Type
    
'     Private i                       As InternalConstants
    
    
'     Private Type State

'         Keys                            As Lyst
'         Items                           As Lyst
'         AutoKey                         As IAutoKey
'         Separator                       As String
'         FirstUse                        As Boolean
        
'     End Type

'     Private s                           As State

'     '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'     '
'     ' class admin
'     '
'     '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'     Public Sub Class_Initialize()
    
'             Guard InvalidNew, Types.IsNotSameInstance(Me, Kvp), i.Location & "Class_Initialize"
    
'     End Sub
    
'     '@Description("Returns a new instnce of a Kvp Class")
'     Public Function Deb(Optional ByVal ipKvp As Kvp = Nothing) As Kvp

'         'Guard UsePredeclaredIdInstance, Types.IsNotSameInstance(Me, Kvp), i.Location & "Debe"
        
'         With New Kvp
        
'             If ipKvp Is Nothing Then
                
'                 Set Deb = .ReadyToUseInstance
                
                
'             Else
                
'                 Set Deb = .ReadyToUseClone(ipKvp)
                
                
'             End If
            
'         End With
        
'     End Function


'     Public Function ReadyToUseInstance() As Kvp

'         'Guard UsePredeclaredIdInstance, Types.IsNotSameInstance(Me, Kvp), i.Location & "Deb"
'         With i
        
'             .Location = "VBALib.Kvp."
'             .DefaultSeparator = Char.comma
'             .ClassName = "Kvp"
'             .CountIsInvalid = -1
'             .FlagAddItems = -1
            
'         End With
        
'         Set s.Keys = Lyst.Deb
'         Set s.Items = Lyst.Deb
'         Set s.AutoKey = Nothing
'         s.Separator = i.DefaultSeparator
'         s.FirstUse = True
    
'         Set ReadyToUseInstance = Me
           
'     End Function
    
    
'     Public Function ReadyToUseClone(ByVal ipKvp As Kvp) As Kvp
        
'         Set s.Keys = ipKvp.GetKeys.Clone
'         Set s.Items = ipKvp.GetItems.Clone
'         Set s.AutoKey = ipKvp.AutoKey
'         s.Separator = ipKvp.Separator
'         s.FirstUse = IIf(ipKvp.AutoKey Is Nothing, True, False)
'         Set ReadyToUseClone = Me

'     End Function
    
    
    
'     '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'     '
'     ' class public members
'     '
'     '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'     '#Region "Adding stuff"
'     ''@Description("Adds items then returns itself. The way in which items are added depends on three scenarios 1 item,2 items more than 2 items)")
'     ' 1 Item
'     '
'     ' IsNotIterable:                        array(Autokey), array(ipArg)
'     ' ListArray or IsIterableItemsByEnum:   Lyst of Autokeys , ListArray(sic) or IsIterableItemsByEnum Items
'     ' IsIterableKeysByEnum:                 iparg.Keys, iparg.Items
'     ' TableArray:                           LystOfAutoKeys, rows as Kvps
'     ' KvPair:                               array(iparg.Key),arrray(iparg.Item)
'     ' To add an iterable as 1 item, encapsulate the iterable in an array e.g. .add array(Iteable)
'     ' 2 items
'     '
'     ' IsPrimitive, Anything:                array(ipParamOne), array(ipParamTwo)
'     ' Is
'     '
'     '
'     ' More than 2 items                     Lyst(AutoKeys), ParamArray
'     '
'     '
'     '@Description("Returns the updated Kvp. Items are added after LastIndex.  The Order in ParamArray is preserved.")
'     Public Function Add(ParamArray ipArgs() As Variant) As Kvp
'         Attribute Add.VB_Description = "Returns the updated Kvp. Items are added after LastIndex.  The Order in ParamArray is preserved."
'         Set Add = InputItems(ipArgs, i.FlagAddItems)
'     End Function
    
    
'     '@Description("Sugar for Add")
'     Public Function EnQueue(ParamArray ipArgs() As Variant) As Kvp
'         Attribute EnQueue.VB_Description = "Sugar for Add"
'         Set EnQueue = InputItems(ipArgs, i.FlagAddItems)
'     End Function
    
    
'     '@Description("Returns the updated Kvp. All Items are inserted Before the specified Index. Order of the ParamArray is preserved.)
'     Public Function InsertAt(ByVal ipStartIndex As Long, ParamArray ipArgs() As Variant) As Kvp

'         Set InsertAt = Me
'         If ipStartIndex < 0 Then Exit Function
'         If ipStartIndex > s.Keys.Count Then Exit Function
            
'         Set InsertAt = InputItems(ipArgs, IIf(ipStartIndex = s.Keys.Count, i.FlagAddItems, ipStartIndex))
        
'     End Function

    
'     '@Description("Returns the updated Kvp.  All Items are inserted After the specified key. The order of the ParamArray is preserved.")
'     Public Function InsertAfterKey(ByVal ipKey As Variant, ParamArray ipArgs() As Variant) As Kvp
' Attribute InsertAfterKey.VB_Description = "Returns the updated Kvp.  All Items are inserted After the specified key. The order of the ParamArray is preserved."
        
'         Set InsertAfterKey = Me
'         If VBA.IsEmpty(ipKey) Then Exit Function
'         If s.Keys.LacksItem(ipKey) Then Exit Function
            
'         '@Ignore IIfSideEffect
'         Set InsertAfterKey = InputItems(ipArgs, IIf(ipKey = s.Keys.Last, i.FlagAddItems, s.Keys.IndexOf(ipKey) + 1))
            
'     End Function

    
'     '@Description("Returns the Modified Kvp.  All Items are inserted Before the specified Key.  The Order of the Paramarray is preserved")
'     Public Function InsertBeforeKey(ByVal ipKey As Variant, ParamArray ipArgs() As Variant) As Kvp
' Attribute InsertBeforeKey.VB_Description = "Returns the Modified Kvp.  All Items are inserted Before the specified Key.  The Order of the Paramarray is preserved"
    
'         Set InsertBeforeKey = Me
'         If VBA.IsEmpty(ipKey) Then Exit Function
'         If s.Keys.LacksItem(ipKey) Then Exit Function
                
'         '@Ignore IIfSideEffect
'         Set InsertBeforeKey = InputItems(ipArgs, IIf(ipKey = s.Keys.First, 0, s.Keys.IndexOf(ipKey)))
        
'     End Function
    
     
'     '@Description("Returns the the modified Kvp. Items are added at Index 0. The order in ParamArray is preserved")
'     Public Function Push(ParamArray ipArgs() As Variant) As Kvp
' Attribute Push.VB_Description = "Returns the the modified Kvp. Items are added at Index 0. The order in ParamArray is preserved"
'         Set Push = InputItems(ipArgs, 0)
'     End Function
'     '#End Region
    
'     '#Region "Removing Stuff"
    
'     '@Description("Returns a Kvp of two Kvp.  Item(0) is the modified host Kvp. Item(1) is the popped items. The order of the popped items is reversed.")
'     Public Function Pop(Optional ByVal ipCount As Long = 1) As Kvp
' Attribute Pop.VB_Description = "Returns a Kvp of two Kvp.  Item(0) is the modified host Kvp. Item(1) is the popped items. The order of the popped items is reversed."
        
'         Dim myresult As Kvp
'         Set myresult = Me.Deb
'         Set Pop = myresult
        
'         myresult.Add Array(Me)
'         myresult.Add Array(Me.Deb)
    
'         If ipCount < 1 Then Exit Function

        
'         Dim myCount As Long
'         myCount = s.Keys.Count
'         If ipCount < myCount Then myCount = ipCount
        
'         Dim myStartIndex As Long
'         myStartIndex = s.Keys.LastIndex - myCount
        
'         Dim myPopped As Kvp
'         Set myPopped = myresult.Item(1)
        
'         myPopped.InputItemsAsIterableIterable _
'             s.Keys.GetRange(myStartIndex, myCount).Reverse, _
'              s.Items.GetRange(myStartIndex, myCount).Reverse, _
'              i.FlagAddItems
             
'         s.Keys.RemoveRange myStartIndex, myCount
'         s.Items.RemoveRange myStartIndex, myCount
             
'     End Function
'     '@Description("Returns the modified Kvp. Removes the Key/Item pairs specified. If no argument is provided the whole Kvp is cleared")
'     Public Function RemoveKeys(ParamArray ipKeys() As Variant) As Kvp
' Attribute RemoveKeys.VB_Description = "Returns the modified Kvp. Removes the Key/Item pairs specified. If no argument is provided the whole Kvp is cleared"
        
'         Set RemoveKeys = Me
'         If Arrays.IsEmptyForwardedParamArray(ipKeys) Then
           
'             s.Keys.Clear
'             s.Items.Clear
'             Exit Function
            
            
'         End If
        
'         Dim myresult As Result
'         Set myresult = Array.Parse(ipKeys)
'         Dim myIndex As Long
'         If myresult.NotOkay Then Exit Function
            
'         Select Case myresult.MessageEnum
            
'             Case Result.NotOkay
            
'                 Exit Function
                
                
'             Case Parsefield.IsNonIterable
            
'                 myIndex = s.Keys.IndexOf(myresult.NonIterableItem)
'                 s.Keys.RemoveAt (myIndex)
'                 s.Items.RemoveAt (myIndex)
                
                
'             Case Parsefield.IsItems, ParseResultCode.IsItemsAndKeys
            
'                 Dim myItem As Variant
'                 Dim myLyst As Lyst
'                 Set myLyst = myresult.Items.Sort.Reverse
'                 For Each myItem In myLyst
                    
'                     myIndex = s.Keys.IndexOf(myItem)
'                     s.Keys.RemoveAt (myItem)
'                     s.Items.RemoveAt (myItem)
                
                    
'                 Next
                
            
'             End Select
        
'     End Function
    
    
     
'     ' '@Description("Items are removed from the Host in the same order as they appear in the Kvp")
'     ' Public Function RemoveAfterKey(Optional ByVal ipKey As Variant, Optional ByVal ipCount As Long = -1) As Kvp
'     '     ' If no arguments are provided remove all
'     '     ' if
        
'     '     Set Remove = Me
    
'     '     If ipCount = 0 Then Exit Function
        
'     '         Dim mystartindex As Long
            
'     '         Dim myCount As Long
            
            
'     '     s.Keys.RemoveRange ipStartIndex, ipCount
'     '     s.Items.RemoveRange ipStartIndex, ipCount
        
'     ' End Function
    
' '    '@Description("Removes the Items specified in the Keys")
' '    Public Function pvRemoveItems(ParamArray ipArgs() As Variant) As Kvp
' '
' '        Dim myKeys As Lyst
' '        Set myKeys = New Lyst
' '
' '        If Arrays.IsEmptyParamArray(ipArgs) Then Exit Function
' '
' '
' '        Select Case True
' '
' '            Case Arrays.IsNotSingleItem(ipArgs)
' '
' '                myKeys.Add ipArgs
' '
' '
' '            ' Use IsNotIterablerather than IsPrimitive so that we do not exclude objects that are not iterables
' '            Case Types.Group.IsNotIterable(ipArgs)
' '
' '                myKeys.Add ipArgs(0)
' '
' '
' '            Case Types.Group.IsIterableKeysByEnum(ipArgs)
' '
' '               myKeys.Add ipArgs(0).Keys
' '
' '
' '            Case Types.Group.IsIterableItemsByEnum(ipArgs)
' '
' '                myKeys.Add ipArgs(0)
' '
' '
' '            Case Types.IsKVPair(ipArgs(0))
' '
' '                myKeys.Add ipArgs(0).Key
' '
' '
' '            Case Else
' '
' '                Guard InvalidKey, Types.IsNotSameType(s.Keys(0), ipArgs(0)), i.Location & "pcRemoveItems", Array(TypeName(s.Keys(0)), ipArgs(0))
' '
' '
' '        End Select
' '
' '        Guard InvalidKey, Types.IsNotSameType(s.Keys(0), myKeys), i.Location & "pcRemoveItems", Array(TypeName(s.Keys(0)), ipArgs(0))
' '
' '        Dim myKvp As Kvp
' '        Set myKvp = New Kvp
' '        Set pvRemoveItems = myKvp
' '
' '        Dim myKey As Variant
' '        For Each myKey In myKeys
' '
' '
' '        Next
' '
' '    End Function
    
'     '@Description("Returns a Kvp of Index vs KVPairs removed from the end of the Host Kvp. The order of Items is the reverse of that in the Host Kvp")
'     Public Function DeQueue(Optional ByVal ipCount As Long = 1) As Kvp
' Attribute DeQueue.VB_Description = "Returns a Kvp of Index vs KVPairs removed from the end of the Host Kvp. The order of Items is the reverse of that in the Host Kvp"
        
'         Dim myKvp As Kvp
'         Set myKvp = Me.Deb
'         Set DeQueue = myKvp
'         If ipCount < 1 Then Exit Function
            
'         Dim myIndex As Long
'         For myIndex = 1 To ipCount
            
'             myKvp.Add s.Keys.First, s.Items.First
'             s.Keys.RemoveAt 0
'             s.Items.RemoveAt 0
            
'         Next
        
'     End Function
' '
' '    '@Description("Returns a Kvp of Index vs KVPairs removed from the end of the Host Kvp. The order of Items is the reverse of that in the Host Kvp")
' '    Public Function Pop(Optional ByVal ipCount As Long = 1, Optional ipOutputType As RemoveType = RemoveType.AsKvp) As Variant
' '
' '        Dim myKvp As Kvp
' '        Set myKvp = Kvp.Deb
' '        'Set myKvp = pvRemove(ipCount)
' '
' '
' '
' '    End Function
    
'     '@Description("Returns a KVPair of the Key and Item from the specified Key. Deletes the Key and Item from the host Kvp")
'     Public Function Pull(Optional ByVal ipKey As Variant) As KVPair
' Attribute Pull.VB_Description = "Returns a KVPair of the Key and Item from the specified Key. Deletes the Key and Item from the host Kvp"

'         Dim myIndex As Long
'         myIndex = s.Keys.IndexOf(ipKey)

'         Set Pull = KVPair.Deb(ipKey, s.Items.Item(myIndex))
'         s.Keys.RemoveAt myIndex
'         s.Items.RemoveAt myIndex

'     End Function

'     '@Description("Returns a KVPair of the Key and Item from the specified index. Deletes the Key and Item from the host Kvp")
'     Public Function PullAt(ByVal ipIndex As Long) As KVPair
' Attribute PullAt.VB_Description = "Returns a KVPair of the Key and Item from the specified index. Deletes the Key and Item from the host Kvp"

'         Set PullAt = KVPair.Deb(s.Keys.Item(ipIndex), s.Items.Item(ipIndex))
'         s.Keys.RemoveAt ipIndex
'         s.Items.RemoveAt ipIndex

'     End Function

'     '@Description("Returns a KVPair of the Key and Item at Index 0. Deletes the Key and Item from the host Kvp")
'     Public Function PullFirst() As KVPair
' Attribute PullFirst.VB_Description = "Returns a KVPair of the Key and Item at Index 0. Deletes the Key and Item from the host Kvp"
        
'         Set PullFirst = PullAt(0)
        
'     End Function

'     '@Description("Returns a KVPair of the Key and Item at Last Index. Deletes the Key and Item from the host Kvp")
'     Public Function PullLast() As KVPair
' Attribute PullLast.VB_Description = "Returns a KVPair of the Key and Item at Last Index. Deletes the Key and Item from the host Kvp"
        
'         Set PullLast = PullAt(s.Keys.LastIndex)
        
'     End Function
    
'     '@Ignore FunctionReturnValueAlwaysDiscarded
'     Public Function Remove(Optional ByVal ipKey As Variant) As Kvp

'         Set Remove = Me
        
'         If VBA.IsMissing(ipKey) Then
        
'             s.Keys.Clear
'             s.Items.Clear
            
'         Else
        
'             Dim myKey As Variant
'             For Each myKey In ipKey
            
'                 Dim myIndex As Long
'                 myIndex = s.Keys.IndexOf(myKey)
'                 s.Keys.RemoveAt myIndex
'                 s.Items.RemoveAt myIndex
                
'             Next
            
'         End If
        
'     End Function

    
'     Public Function RemoveAt(ByVal ipIndex As Long) As Kvp
        
        
'         s.Items.RemoveAt ipIndex
'         s.Keys.RemoveAt ipIndex
'         Set RemoveAt = Me
        
'     End Function

'     '@Description("Returns the modified Host Kvp after deleting all Key/Item pairs from the Host")
'     Public Function RemoveAll() As Kvp
' Attribute RemoveAll.VB_Description = "Returns the modified Host Kvp after deleting all Key/Item pairs from the Host"
        
'         s.Keys.Clear
'         s.Items.Clear
        
'         Set RemoveAll = Me
        
'     End Function

'     '@Description("Returns the modified host Kvp after removing the Key and Item at Index 0")
'     Public Function RemoveFirst() As Kvp
' Attribute RemoveFirst.VB_Description = "Returns the modified host Kvp after removing the Key and Item at Index 0"
'         Set RemoveFirst = RemoveAt(0)
'     End Function

'     '@Description("Returns the modified host Kvp after removing the Key and Item at LastIndex")
'     Public Function RemoveLast() As Kvp
' Attribute RemoveLast.VB_Description = "Returns the modified host Kvp after removing the Key and Item at LastIndex"
'         Set RemoveLast = RemoveAt(s.Keys.Count - 1)
'     End Function
    
'     '#End Region
    
'     '@Description("Returns the number of key/item pairs in the Kvp")
'     Public Function Count() As Long
' Attribute Count.VB_Description = "Returns the number of key/item pairs in the Kvp"
'         Count = s.Keys.Count
'     End Function
    
    
'     '@Description("Returns a copy of the Kvp. If Items are objects then a shallow copy is made unless the object supports a clone Method.")
'     Public Function Clone() As Kvp
' Attribute Clone.VB_Description = "Returns a copy of the Kvp. If Items are objects then a shallow copy is made unless the object supports a clone Method."
        
'         Set Clone = Me.Deb(Me)
        
'     End Function
    
'     '@Description("Decrements the Items  at the given Keys by the specified amount if the Items are Numbers")
'     Public Function Dec(Optional ByVal ipKeys As Variant = Empty, Optional ByVal ipDecrement As Variant) As Kvp
' Attribute Dec.VB_Description = "Decrements the Items  at the given Keys by the specified amount if the Items are Numbers"
'         If VBA.IsMissing(ipDecrement) Then ipDecrement = i.DefaultAdjustAmount
'         Set Dec = Me
'         AdjustbyKey ipKeys, -ipDecrement
        
'     End Function

'     '@Description("Decrements the Items at the given indexes by the specified amount if the Items are Numbers")
'     Public Function DecAt(ByVal ipIndexes As Variant, Optional ByVal ipDecrement As Single) As Kvp
' Attribute DecAt.VB_Description = "Decrements the Items at the given indexes by the specified amount if the Items are Numbers"
'         If VBA.IsMissing(ipDecrement) Then ipDecrement = i.DefaultAdjustAmount
'         Set DecAt = Me
'         AdjustByIndex ipIndexes, -ipDecrement
         
'     End Function


    


'     ' Public Property Get ErrorOutPut() As ErrorReporter
'     '     ErrorOutPut = s.ErrorOutPut
'     ' End Property

'     ' Public Property Let ErrorOutPut(ByVal ipValue As ErrorReporter)
'     '     s.ErrorOutPut = ipValue
'     ' End Property


    
'     '@Description("Returns a Kvp comprised of Key/Item pairs where the Key appears in both the Host Kvp and the input parameter")
'     Public Function FilterByKeys(ByVal ipKeysIterable As Variant) As Kvp
' Attribute FilterByKeys.VB_Description = "Returns a Kvp comprised of Key/Item pairs where the Key appears in both the Host Kvp and the input parameter"
'        ' Preference should be given to using the specific KeysIn<xxx> method
'        Dim myresult As Kvp
'        Set myresult = Me.Deb
'        Set FilterByKeys = myresult

'        If VBA.IsEmpty(ipKeysIterable) Then Exit Function

'        Dim myKeys As Lyst
'        If Types.IsTypeByName(Types.Name.OfLyst, ipKeysIterable) Then

'            Set myKeys = ipKeysIterable


'        ElseIf Types.Group.IsIterableKeysByEnum(ipKeysIterable) Then

'            Set myKeys = Types.Iterable.ToLyst(ipKeysIterable.Keys)


'        Else

'            Set myKeys = Types.Iterable.ToLyst(ipKeysIterable)


'        End If

'        myresult.Add 0&, Me.KeysInAandB(myKeys)
'        myresult.Add 1&, Me.KeysInAOnly(myKeys)
'        myresult.Add 2&, Me.KeysInBOnly(myKeys)

'        Set FilterByKeys = myresult
        
'     End Function

'     '@Description("Returns a KVPair of the Key and Item at Index 0")
'     Public Function GetFirst() As KVPair
' Attribute GetFirst.VB_Description = "Returns a KVPair of the Key and Item at Index 0"
        
'         If s.Keys.Count = 0 Then
            
'             Set GetFirst = KVPair.Deb
            
'         Else
            
'             Set GetFirst = KVPair.Deb(s.Keys.Item(0), s.Items.Item(0))
            
'         End If
        
'     End Function

'     '@Description("Returns a Kvp of Key vs Index at which the key is found")
'     Public Function GetKeysWithValue(ByVal ipValue As Variant, Optional ByVal ipIndexer As IndexSelector = IndexSelector.IsIndex) As Kvp
' Attribute GetKeysWithValue.VB_Description = "Returns a Kvp of Key vs Index at which the key is found"
        
'         If Not s.Items.HoldsItem(ipValue) Then
        
'             Set GetKeysWithValue = Nothing
'             Exit Function
            
'         End If
        
'         Dim myresult As Kvp
'         Set myresult = Me.Deb

'         Dim myIndex As Long
'         For myIndex = 0 To Me.LastIndex

'             If s.Items.Item(myIndex) = ipValue Then
            
'                 If ipIndexer - IndexSelector.IsIndex Then
                
'                     myresult.Add s.Keys.Item(myIndex), myIndex
                    
'                 Else
                    
'                     myresult.Add myIndex, s.Keys.Item(myIndex)
                    
'                 End If
                
'             End If
            
'         Next

'         Set GetKeysWithValue = myresult
        
'     End Function

'     '@Description("Returns the zero based index of the Key")
'     Public Function GetIndexOfKey(ByVal ipKey As Variant) As Long
' Attribute GetIndexOfKey.VB_Description = "Returns the zero based index of the Key"

'         If Types.IsEmpty(ipKey) Then
        
'             GetIndexOfKey = -1
            
'         Else
            
'             GetIndexOfKey = s.Keys.IndexOf(ipKey)
            
'         End If
        
'     End Function


'     '@Description("Returns a kvp of Index vs Key")
'     Public Function GetIndexOfValue(ByVal ipValue As Variant, Optional ByVal ipOrganiseby As IndexSelector = IndexSelector.IsIndex) As Kvp
' Attribute GetIndexOfValue.VB_Description = "Returns a kvp of Index vs Key"
'         's.values may hold more than one item with the same value so we return a Kvp
'         Set GetIndexOfValue = Me.MirrorByValue(ipOrganiseby).Item(ipValue)
'     End Function

'     '@Description("Returns a shallow copy of the Keys")
'     Public Function GetKeys() As Lyst
' Attribute GetKeys.VB_Description = "Returns a shallow copy of the Keys"
        
'         If s.Keys Is Nothing Then
        
'             Set GetKeys = Lyst.Deb
            
'         Else
        
'             Set GetKeys = s.Keys
            
'         End If
        
'     End Function

'     '@Description("Returns a KVPair of the Key and Item at LastIndex")
'     Public Function GetLast() As KVPair
' Attribute GetLast.VB_Description = "Returns a KVPair of the Key and Item at LastIndex"
'         Set GetLast = KVPair.Deb(s.Keys.Item(Me.LastIndex), s.Items.Item(Me.LastIndex))
'     End Function
    
'     '@Description("Returns a Lyst of the specified Items. An empty Paramarray will return all Iems. If the item is an object the Clone methos will be used if available. ")
'     Public Function GetItems(ParamArray ipKeys() As Variant) As Lyst
' Attribute GetItems.VB_Description = "Returns a Lyst of the specified Items. An empty Paramarray will return all Iems. If the item is an object the Clone methos will be used if available. "

'         Dim myLyst As Lyst
'         Set myLyst = Lyst.Deb
'         Set GetItems = myLyst
'         Dim myKeys As Variant
       
'         Select Case True
            
'             ' In the case of an empty paramarray we return all items
'             Case Arrays.IsEmptyForwardedParamArray(ipKeys)

'                 Set myKeys = s.Keys
                
        
'             Case Arrays.IsNotSingleItem(ipKeys)
            
'                 myKeys = ipKeys
            
'             ' From here onwards we have a single item paramarray
'             Case Types.Group.IsNotIterable(ipKeys(0))
                
'                 myKeys = Array(ipKeys(0))
                
'             ' If the single item is an array, only accept a ListArray
'             Case VBA.IsArray(ipKeys(0))
                    
'                 Guard Id.NotListArray, Arrays.IsNotListArray(ipKeys(0)), i.Location & "GetItems"
'                 myKeys = ipKeys(0)
                
            
'             Case Types.Group.IsIterableItemsByEnum(ipKeys(0))
                
'                  Set myKeys = ipKeys(0)
                 
                 
'             Case Types.Group.IsIterableKeysByEnum(ipKeys(0))
                
'                 Set myKeys = ipKeys(0).Keys
                
                
'             Case Else
            
'                 Guard _
'                     Id.InvalidKey, _
'                     True, _
'                     i.Location & "Items", _
'                     ipAltMessage:=Fmt.Txt("The Key '{0}' is unexpected", TypeName(ipKeys(0)))
                
'         End Select
        
'         ' if items have a clone method then we call the clone method
        
'         Dim myKey As Variant
'         For Each myKey In myKeys
            
'             If Types.HasCloneMethod(myKey) Then
                
'                 myLyst.Add Me.Item(myKey).Clone
                
'             Else
                
'                 myLyst.Add Me.Item(myKey)
                
'             End If
            
'         Next
        
'     End Function

    
    
'     ' <summary> NextPair/PrevPair get the indicated KVPair from the Host
'     ' Dictionary. These methods are not intended to be used as iterators
'     ' but as ad hoc requests for the next/prev KVPair in the Kvp. If the
'     ' supplied key is the last/first key in the Dictionary then ipLoop
'     ' will determine if the KVPair returned will be null:null (ipLoop =
'     ' false) or the first/last KVPair in the Dictionary (ipLoop=True)
'     ' </summary> <paramname="ipKey">The Key for which the next/prev
'     ' KVPair should be returned. <paramname="ipLoop">Wraps around the
'     ' Dictionary if True </param> <returns>The Indicated KVPair</returns></param>
'     Public Function NextPair(ByVal ipKey As Variant, Optional ByVal ipTreatKeysArrayAsLoop As Boolean = True) As KVPair

'         Dim myIndex As Long
'         myIndex = s.Keys.IndexOf(ipKey) + 1

'         If myIndex >= s.Keys.Count Then
        
'             If ipTreatKeysArrayAsLoop Then
            
'                 Set NextPair = KVPair.Deb(s.Keys.Item(0), s.Items.Item(0))
                
'             Else
            
'                 Set NextPair = Nothing
                
'             End If
            
'         Else
        
'             Set NextPair = KVPair.Deb(s.Keys.Item(myIndex), s.Items.Item(myIndex))
            
'         End If
        
'     End Function


'     Public Function PrevPair(ByVal ipKey As Variant, Optional ByVal ipTreatKeysArrayAsLoop As Boolean = True) As KVPair

'         Dim myIndex As Long
'         myIndex = s.Keys.IndexOf(ipKey) - 1
    
'         If myIndex < 0 Then
        
'             If ipTreatKeysArrayAsLoop Then
            
'                 Set PrevPair = KVPair.Deb(s.Keys.Item(Me.LastIndex), s.Items.Item(Me.LastIndex))
                
'             Else
            
'                 Set PrevPair = Nothing
                
'             End If
            
'         Else
        
'             Set PrevPair = KVPair.Deb(s.Keys.Item(myIndex), s.Items.Item(myIndex))
            
'         End If
        
'     End Function

'     '@Description("Returns True if the value is a Key of the Kvp")
'     Public Function HoldsKey(ByVal Key As Variant) As Boolean
' Attribute HoldsKey.VB_Description = "Returns True if the value is a Key of the Kvp"
'         HoldsKey = s.Keys.HoldsItem(Key)
'     End Function

'     '@Description("Returns True if the value is an Item of the Kvp")
'     Public Function HoldsValue(ByVal ipValue As Variant) As Boolean
' Attribute HoldsValue.VB_Description = "Returns True if the value is an Item of the Kvp"
'         HoldsValue = s.Items.HoldsItem(ipValue)
'     End Function
    
'     '@Description("Increments the Items  at the given Keys by the specified amount if the Items are Numbers")
'     Public Function Inc(Optional ByVal ipKeys As Variant = Empty, Optional ByVal ipIncrement As Double) As Kvp
' Attribute Inc.VB_Description = "Increments the Items  at the given Keys by the specified amount if the Items are Numbers"
'         If VBA.IsMissing(ipIncrement) Then ipIncrement = i.DefaultAdjustAmount
'         Set Inc = Me
'         AdjustbyKey ipKeys, ipIncrement
    
'     End Function

    
'     Public Function IncAt(Optional ByVal ipIndexes As Variant = Empty, Optional ByVal ipIncrement As Double) As Kvp
'         If VBA.IsMissing(ipIncrement) Then ipIncrement = i.DefaultAdjustAmount
'         Set IncAt = Me
'         AdjustByIndex ipIndexes, ipIncrement
        
'     End Function
    
'     '@Description("True if Count = 0, added to match terminology in Lyst and Group Iterable/Arrays")
'     Public Function HasNoItems() As Boolean
' Attribute HasNoItems.VB_Description = "True if Count = 0, added to match terminology in Lyst and Group Iterable/Arrays"
'         HasNoItems = Count = 0
'     End Function

    
'     '@Description("True if Count > 0, added to match terminology in Lyst and Group Iterable/Arrays")
'     Public Function HasItems() As Boolean
' Attribute HasItems.VB_Description = "True if Count > 0, added to match terminology in Lyst and Group Iterable/Arrays"
'         HasItems = Not (Count = 0)
'     End Function

'     '@Description("Returns true if the items values onlu occur once")
'     Public Function IsUnique() As Boolean
' Attribute IsUnique.VB_Description = "Returns true if the items values onlu occur once"
'         IsUnique = Me.MirrorFirstValues.Item(1&).Count = 0
'     End Function

'     '@Description("Returns True is Item values occur more than once")
'     Public Function IsNotUnique() As Boolean
' Attribute IsNotUnique.VB_Description = "Returns True is Item values occur more than once"
'         IsNotUnique = Not IsUnique
'     End Function



'     '@DefaultMember
'     Public Property Get Item(ByVal ipKey As Variant) As Variant
' Attribute Item.VB_UserMemId = 0
        
'         Dim myIndex As Long
'         myIndex = s.Keys.IndexOf(ipKey)
'         If IsObject(s.Items.Item(myIndex)) Then
        
'             Set Item = s.Items.Item(myIndex)
            
'         Else
        
'             Item = s.Items.Item(myIndex)
        
'         End If
        
'     End Property

'     Public Property Let Item(ByVal ipKey As Variant, ByVal ipValue As Variant)
        
'         Guard UnexpectedEmpty, VBA.IsEmpty(ipKey), i.Location & "Let Item"
        
'         Dim myIndex As Long
'         myIndex = s.Keys.IndexOf(ipKey)
'         If VBA.IsObject(ipValue) Then
        
'             Set s.Items.Item(myIndex) = ipValue
            
'         Else
        
'             s.Items.Item(myIndex) = ipValue
            
'         End If
        
'     End Property


'     Public Property Get ItemAt(ByVal ipIndex As Long) As Variant
        
'         Guard Id.StartIndexWasZeroResetToOne, ipIndex < 0, i.Location & "ItemAt"
'         Guard StartIndexExceedsItemCount, ipIndex > Me.LastIndex, i.Location & "ItemAt"
        
'         If IsObject(s.Items.Item(ipIndex)) Then
        
'             Set ItemAt = s.Items.Item(ipIndex)
            
'         Else
        
'             ItemAt = s.Items.Item(ipIndex)
            
'         End If
        
'     End Property

'     Public Property Set ItemAt(ByVal ipIndex As Long, ByVal ipValue As Variant)
        
'         Guard StartIndexWasZeroResetToOne, ipIndex < 0, i.Location & "ItemAt"
'         Guard StartIndexExceedsItemCount, ipIndex > Me.LastIndex, i.Location & "ItemAt"

'         If IsObject(ipValue) Then
        
'             Set s.Items.Item(ipIndex) = ipValue
            
'         Else
        
'             s.Items.Item(ipIndex) = ipValue
            
'         End If
        
'     End Property
    
'     '@Description("Wrapper for GetValues to allow methods compatibility with Scripting.Dictionaries")
'     Public Function Items() As Variant
' Attribute Items.VB_Description = "Wrapper for GetValues to allow methods compatibility with Scripting.Dictionaries"
'         Items = s.Items.ToArray
'     End Function


'     '@Description("Wrapper for GetKeys to allow compatibility with Scripting.Dictionaries")
'     Public Function Keys() As Variant
' Attribute Keys.VB_Description = "Wrapper for GetKeys to allow compatibility with Scripting.Dictionaries"
'         Keys = s.Keys.ToArray
'     End Function


'     Public Function KeysInAOnly(ByVal ipB As Kvp) As Kvp

'         Dim myresult As Kvp
'         Set myresult = Me.Deb

'         Dim myKey As Variant
'         For Each myKey In s.Keys

'             If ipB.LacksKey(myKey) Then
            
'                 myresult.Add Me.Item(myKey), myKey
                
'             End If
            
'         Next

'         Set KeysInAOnly = myresult
        
'     End Function


'     Public Function KeysInBOnly(ByVal ipB As Kvp) As Kvp

'         Dim myresult As Kvp
'         Set myresult = Me.Deb

'         Dim myKey As Variant
'         For Each myKey In ipB.GetKeys

'             If Me.LacksKey(myKey) Then
            
'                 myresult.Add ipB.Item(myKey), myKey
                
'             End If
            
'         Next

'         Set KeysInBOnly = myresult
        
'     End Function


'     Public Function KeysAllAandOnlyB(ByVal ipB As Kvp) As Kvp

'         Dim myresult As Kvp
'         Set myresult = Me.Clone
        
'         Dim myResultB As Kvp
'         Set myResultB = Me.KeysInBOnly(ipB)
'         myresult.Add myResultB.GetItems, myResultB.GetKeys
        
'         Set KeysAllAandOnlyB = myresult
        
'     End Function


'     Public Function KeysInAandB(ByVal ipB As Kvp) As Kvp
        
'         Dim myresult As Kvp
'         Set myresult = Me.Deb
        
'         Dim myKey As Variant
'         For Each myKey In s.Keys
        
'             If ipB.HoldsKey(myKey) Then
        
'                 myresult.Add Me.Item(myKey), myKey
        
'             End If
            
'         Next
        
'         Set KeysInAandB = myresult
        
'     End Function


'     Public Function KVPairsInAandB(ByVal ipB As Kvp) As Kvp
'         ' myInB is used for keys in B that have a different value to A
'         Dim myresult As Kvp
'         Set myresult = Me.Deb
        
'         Dim myKey As Variant
'         For Each myKey In s.Keys
        
'             If ipB.HoldsKey(myKey) Then
        
'                 If Me.Item(myKey) = ipB.Item(myKey) Then

'                     myresult.Add Me.Item(myKey), myKey
                    
'                 End If
        
'             End If
            
'         Next
        
'         Set KVPairsInAandB = myresult
        
'     End Function


'     Public Function KeysNotInBothAandB(ByVal ipB As Kvp) As Kvp

'         Dim myresult As Kvp
'         Set myresult = ipB.Clone
        
'         Dim myKey As Variant
'         For Each myKey In s.Keys
        
'             If myresult.HoldsKey(myKey) Then
            
'                 myresult.Remove myKey
                
'             Else
            
'                 myresult.Add Me.Item(myKey), myKey
                
'             End If
        
'         Next
        
'         Set KeysNotInBothAandB = myresult
        
'     End Function


'     Public Function LacksKey(ByVal ipKey As Variant) As Boolean
'         LacksKey = Not HoldsKey(ipKey)
'     End Function


'     Public Function LacksValue(ByVal ipValue As Variant) As Boolean
'         LacksValue = Not HoldsValue(ipValue)
'     End Function


'     Public Function LastIndex() As Long

'         LastIndex = -1
        
'         If s.Keys Is Nothing Then Exit Function
        
'         LastIndex = s.Keys.LastIndex
        
'     End Function


'     'returns a Kvp with values as keys.  Each Value is linked
'     ' to a Kvp of Index vs Key
'     Public Function MirrorByValue(Optional ByVal ipOrganiseby As IndexSelector = IndexSelector.IsIndex) As Kvp
        
'         Dim myresult As Kvp
'         Set myresult = Me.Deb
        
'         Dim myKey  As Variant
'         For Each myKey In s.Keys
        
'             Dim myIndex As Variant
'             myIndex = s.Keys.IndexOf(myKey)
'             If myresult.LacksKey(s.Items.Item(myIndex)) Then
            
'                 myresult.Add s.Items.Item(myIndex), Me.Deb
                
'             End If
            
'             If ipOrganiseby = IndexSelector.IsIndex Then
            
'                 myresult.Item(s.Items.Item(myIndex)).Add myIndex, myKey
                
'             Else
            
'                 myresult.Item(s.Items.Item(myIndex)).Add myKey, myIndex
                
'             End If
            
'         Next
        
'         Set MirrorByValue = myresult

'     End Function

'     '@Description("Returns a new Kvp where each value has been transformed by the IMap Object")
' '    Public Function Map(ByVal ipMapper As IMap) As Kvp
' '
' '        Dim myKvp As Kvp
' '        Set myKvp = Kvp.Deb
' '
' '        Dim myIndex As Long
' '        Dim myMaxIndex As Long
' '        myMaxIndex = Me.LastIndex
' '        For myIndex = 0 To myMaxIndex
' '
' '            myKvp.Add ipMapper.ExecMap(s.Values.Item(myIndex)), s.Keys.Item(myIndex)
' '
' '        Next
' '
' '        Set Map = myKvp
' '
' '    End Function
'     'todo: need to add byindex of bykey
'     Public Function MirrorFirstValues(Optional ByVal ipOrganiseby As IndexSelector = IndexSelector.IsIndex) As Kvp
' Attribute MirrorFirstValues.VB_Description = "Returns a new Kvp where each value has been transformed by the IMap Object"

'         Dim myFirstValues As Kvp
'         Set myFirstValues = Me.Deb
        
'         Dim myDupValues As Kvp
'         Set myDupValues = Me.Deb

'         Dim myIndex As Long
'         For myIndex = 0 To s.Keys.Count - 1
        
'             If myFirstValues.LacksKey(s.Items.Item(myIndex)) Then
            
'                 myFirstValues.Add s.Keys.Item(myIndex), s.Items.Item(myIndex)
                
'             Else
            
'                 myDupValues.Add s.Items.Item(myIndex), s.Keys.Item(myIndex)
                
'             End If
            
'         Next
            
'         Set MirrorFirstValues = Me.Deb.Add(Array(myFirstValues, myDupValues))
        
'     End Function


'     '@Enumerator
'     '@Ignore EmptyMethod
'     Public Function NewEnum() As IUnknown
' Attribute NewEnum.VB_UserMemId = -4
'     '    Static myKeysIndex As Long
'     '    Static myValuesIndex As Long
'     '
'     '    If myKeysIndex >= s.Keys.Count Then
        
'         '  Set NewEnum = KVPair.Deb(s.Keys.[_NewEnum], s.Values.[_NewEnum])
'     '        myKeysIndex = 0
'     '        myValuesIndex = 0
'     '
'     '    Else
'     '
'     '        Set NewEnum = GetPair(myKeysIndex)
'     '        myKeysIndex = myKeysIndex + 1
'     '        myValuesIndex = myValuesIndex + 1
'     '
'     '    End If
        
'     End Function


'     'Public Function MissingKeys(ByVal ipKeysIterable As Variant) As Kvp
'     '
'     '    Dim myKeysList As ArrayList
'     '    Set myKeysList = GetArrayAsList(ipKeysIterable)
'     '
'     '    Dim myMissingInHost As Kvp
'     '    Set myMissingInHost = Kvp.Deb
'     '
'     '    Dim myKey As Variant
'     '    For Each myKey In myKeysList
'     '
'     '        If Not s.Keys.ContainsKey(myKey) Then
'     '
'     '            myMissingInHost.Add myKey
'     '
'     '        End If
'     '
'     '    Next
'     '
'     '    Dim myMissingInArray As Kvp
'     '    Set myMissingInArray = Kvp.Deb
'     '
'     '    For Each myKey In s.Keys
'     '
'     '        If Not myKeysList.Contains(myKey) Then
'     '
'     '            myMissingInArray.Add myKey
'     '
'     '        End If
'     '    Next
'     '
'     '    Set MissingKeys = Kvp.Deb.Add(Array(myMissingInHost, myMissingInArray))
'     '
'     'End Function

'     '@Description("Returns the string 'Kvp'")
'     Public Function Name() As String
' Attribute Name.VB_Description = "Returns the string 'Kvp'"
'         Name = i.ClassName
'     End Function

'     '@Description("Returns a Kvp of maximum and minimum values.  Keys are the max and min value, associated with the keys is a Kvp of Index vs Key for each value corresponding to the parent key.")
'     Public Function NumMaxMin() As Kvp
' Attribute NumMaxMin.VB_Description = "Returns a Kvp of maximum and minimum values.  Keys are the max and min value, associated with the keys is a Kvp of Index vs Key for each value corresponding to the parent key."
        
'         Guard IsNotNumber, Types.Group.IsNotNumber(s.Items.Item(0)), i.Location & "NumMaxMin", Array(TypeName(s.Items.Item(0)), Join(Types.Group.Numbers.ToArray, ","))
        
'         Dim myresult As Kvp
'         Set myresult = Me.Deb
        
'         Dim myValues As VBALib.Lyst
'         Set myValues = s.Items.Clone
'         myValues.Sort
        
'         'Item 0 of the KVp is the minimum values
'         Const maMin As Long = 0
'         myresult.Add Me.Deb, maMin
        
'         'Item 1 of the Kvp is the maximum values
'         Const maMax As Long = 1
'         myresult.Add Me.Deb, maMax

'         ' A maximum or minimum value may occur more than once
'         ' so we populate the max and min kvp  with the key vs value
'         ' of each found max or min value
        
'         Dim myLbound As Long
'         myLbound = 0
        
'         Dim myUbound As Long
'         myUbound = Me.LastIndex
        
'         Dim myIndex As Long
'         For myIndex = myLbound To myUbound

'             Select Case s.Items.Item(myIndex)
            
'                 Case myValues.Item(myLbound)
                    
'                     myresult.Item(maMin).Add s.Items.Item(myIndex), s.Keys.Item(myIndex)
                    
            
'                 Case myValues.Item(myUbound)
                    
'                     myresult.Item(maMax).Add s.Items.Item(myIndex), s.Keys.Item(myIndex)
                    
'             End Select
            
'         Next

'         Set NumMaxMin = myresult
        
        
        
'     End Function


'     'Public Function PushAt(ByVal ipIndex As Long, ByVal ipValue As Variant, Optional ByVal ipKey As Variant = Empty)
'     '
'     '
'     'End Function
'     '
'     'public function PushByKey( byval ipKey as Variant, byval ipValue

'     '@Description("Sugar for InsertFirst")



'     Public Function Reverse() As Kvp
' Attribute Reverse.VB_Description = "Sugar for InsertFirst"

'         s.Keys.Reverse
'         s.Items.Reverse
        
'         Set Reverse = Me

'     End Function


'     Public Property Get Separator() As String
'         Separator = s.Separator
'     End Property

'     Public Property Let Separator(ByVal ipSeparator As String)
'         s.Separator = ipSeparator
'     End Property


'     Public Function SetAutoKeyToAutoKeyByNumber(Optional ByVal ipFirstKey As Variant = 0&) As Kvp

'         Guard AutoKeyResetNotAllowed, Not s.FirstUse, i.Location & "SetAutoKeyByNumber"
'         Guard IsNotNumber, Types.Group.IsNotNumber(ipFirstKey), i.Location & "SetAutoKeyByNumvber"
        
        
'         Set s.AutoKey = AutoKeyByNumber.Deb(ipFirstKey)
'         s.FirstUse = False
'         Set SetAutoKeyToAutoKeyByNumber = Me
        
'     End Function


'     Public Function SetAutoKeyToAutoKeyByString _
'     ( _
'         Optional ByVal ipFirstKey As String = AutoKeyAid.DefaultInitialStringKey, _
'         Optional ByVal ipCharSequence As String = AutoKeyAid.DefaultAllowedCharListForStringKey _
'     ) As Kvp
        
'         Guard AutoKeyResetNotAllowed, Not s.FirstUse, i.Location & "SetAutoKeyByString"
'         Guard IsNotString, Types.IsNotString(ipFirstKey), i.Location & "SetAutoKeyByString"
            
'         Set s.AutoKey = AutoKeyByString.Deb(ipFirstKey, ipCharSequence)
'         s.FirstUse = False
'         Set SetAutoKeyToAutoKeyByString = Me
        
'     End Function


'     Public Function SetAutoKeyToAutoKeyByIndex(ByVal ipKeysIterable As Variant, Optional ByVal ipStartIndex As Variant = AutoKeyAid.DefaultKeyIndexForArrayList) As Kvp
        
'         Set SetAutoKeyToAutoKeyByIndex = Me
        
'         Dim myPlace As String
'         myPlace = i.Location & "SetToAutoKeyByIndex"
'         Guard AutoKeyResetNotAllowed, Not s.FirstUse, myPlace
'         Guard NotIterableType, Types.Group.IsNotIterable(ipKeysIterable), myPlace
'         Guard HasNoItems, Types.Iterable.HasNoItems(ipKeysIterable), myPlace

    
'         Dim myLyst As Lyst
'         Set myLyst = Types.Iterable.ToLyst(ipKeysIterable)
        
'         Dim myresult As Result
'         'Guard GuardClause.IndexLessThanFirstIndex, VBA.IsEmpty(Types.Iterable.TryExtent(ipKeysIterable, myResult).Item(Extent.IsFirstIndex)), myPlace
'         Dim myKeysFirstIndex As Long
'         If Types.Iterable.TryExtent(ipKeysIterable, myresult).NotOkay Then Exit Function
'         myKeysFirstIndex = myresult.Item(ItemExtent.IsFirstIndex)
'         ' Normalise ipStartIndex for use when ipKeysIterable is converted to an ArrayList
'         ' An arraylist is required to get access to the 'IndexOf' method
'         ' ipStartIndex is the first index to use with ipKeysIterable and is not necessarily
'         ' the first item in the iterable
        
'         Dim myStartIndex As Long
'         Select Case True
                
'             Case Types.Group.IsNotNumber(ipStartIndex)
            
'                 ' case where a value has been provided rather than an index
'                 ' only valid for when ipFirstIndex is not a number
                
'                 myStartIndex = myLyst.IndexOf(ipStartIndex) - myKeysFirstIndex + 1
                
'             Case Else
            
'                 myStartIndex = ipStartIndex - myKeysFirstIndex ' + 1
            
'         End Select
        
'         Set s.AutoKey = AutoKeyByIndex.Deb(myLyst, myStartIndex)
'         s.FirstUse = False
'         Set SetAutoKeyToAutoKeyByIndex = Me
            
            
'     End Function
    
'     Public Function SumKeys() As LongLong

'         Guard Id.IsNotNumber, Types.Group.IsNotNumber(s.Keys.Item(0)), i.Location & "SumKeys"

'         Dim mySum As LongLong
'         Dim myKey As Variant
'         For Each myKey In s.Keys
        
'             mySum = mySum + myKey
            
'         Next

'         SumKeys = mySum
        
'     End Function


'     Public Function SumValues() As LongLong
        
'         Guard Id.IsNotNumber, Types.Group.IsNotNumber(s.Items.Item(0)), i.Location & "SumValues"

'         Dim mySum As LongLong
'         Dim myValue As Variant
'         For Each myValue In s.Items
        
'             mySum = mySum + myValue
            
'         Next

'         SumValues = mySum
        
'     End Function



'     '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'     '
'     ' class private methods
'     '
'     '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'     ' Add methods which specify a Key MUST ensure that they set the current key in the AutoKey
'     ' to the last key specified after completing all adds to ensure continuity of keys
'     ' from the last key used by the method

'     ' Private Sub pvAddIterable(ByVal ipIterable As Variant)
'     ' ' The iterable may be a variant array, a collection an arraylist or other
'     ' ' one dimensional object that can be enumerate using for each
'     '     s.Logger.Push "Private AddIterable"
        
'     '     If s.FirstUse Then pvInitialiseAutoKey 0&

'     '     Dim myKey As Variant
'     '     Dim myValue As Variant
'     '     For Each myValue In ipIterable
        
'     '         myKey = s.AutoKey.GetNextKey
'     '         pvDoAdd myKey, myValue
        
'     '     Next
        
'     '     s.AutoKey.CurrentKey = myKey
'     '     s.Logger.Pop
            
'     ' End Sub

'     'Description("Determines if there are 1, 2 or 3 arguments and then call appropriate sub for the number of arguments)")
'     Friend Function InputItems(ByVal ipArgsArray As Variant, ByVal ipInputType As IterableRangeInputType, Optional ByVal ipStartIndex As Long) As Kvp
         
'         ' Insertion is defined by ipstartindex being 0 or larger
'         Set InputItems = Me
            
'         Dim myArgsCount As Long
'         myArgsCount = UBound(ipArgsArray, 1) + 1
'         Select Case myArgsCount
        
'             Case 0
            
'                 Exit Function
                
'             Case 1
            
'                 InputItemsOneParam CVar(ipArgsArray(0)), ipStartIndex 'complete
                
                
'             Case 2
            
'                 InputItemsTwoParams CVar(ipArgsArray(0)), CVar(ipArgsArray(1)), ipStartIndex
                
                    
'             Case Is > 2
                    
'                 InputItemsThreeOrMoreParams CVar(ipArgsArray), ipStartIndex ' complete
                
            
'         End Select
        
        
'     End Function
            
'     'Description("Adds or Inserts a ParamArray of 1 item.  The action taken is dependent of the type of the item")
'     Friend Sub InputItemsOneParam(ByVal ipArg As Variant, ByVal ipStartIndex As Long)
        
'         ' ' s.firstuse is tested here becauase some of the cases use s.autokey
'         ' If s.FirstUse Then InjectAutoKey
            
'         ' primitive, Kvp and 2d arrays need special treatment
'         Select Case True
            
'             ' Use IsNotIterablerather than IsPrimitive so that we do not exclude objects that are not iterables
'             Case Types.Group.IsNotIterable(ipArg)
               
'                 If s.FirstUse Then InjectAutoKey
'                 InputItemsAsIterableIterable Array(s.AutoKey.GetNextKey), Array(ipArg), ipStartIndex
            
                
'             Case Arrays.IsMDArray(ipArg)
            
'                 InputItemsAsIterableIterable Array(AutoKey.GetNextKey), Array(ipArg), ipStartIndex
                
                
'             Case Arrays.IsTableArray(ipArg)
            
'                 ' No KeysOrientation is specified with one parameter
'                 ' so default to RankIsRowFirstItemActionIsNoAction
'                 Dim myLystofLysts As Lyst
'                 Set myLystofLysts = Enums.TableToLystActions.Exec(RankIsRowFirstItemActionIsNoAction, ipArg)
'                 InputItemsAsIterableIterable AutoKey.GetKeySequence(myLystofLysts.Count), myLystofLysts, ipStartIndex
                
                
'             Case Types.Group.IsIterableItemsByEnum(ipArg)
                             
'                 If Types.Iterable.HasNoItems(ipArg) Then Exit Sub
                
'                 InputItemsAsIterableIterable s.AutoKey.GetKeySequence(Types.Iterable.Count(ipArg)), ipArg, ipStartIndex
            
                
'             Case Types.Group.IsIterableKeysByEnum(ipArg)
        
'                 InputItemsAsIterableIterable ipArg.Keys, ipArg.Items, ipStartIndex
                
                
'             Case Else
            
'                 Guard IsNotIterable, i.Location & "pvAddOrInsertOneParam", TypeName(ipArg)
'                 Exit Sub
            
                
'         End Select
        
'     End Sub


'     Friend Sub InputItemsTwoParams(ByVal ipParamOne As Variant, ByVal ipParamTwo As Variant, ByVal ipStartIndex As Long)

'     ' To add two iterables as objects, rather than as their component items,
'     ' combine the two iterables into an array so that the ParamArray
'     ' consists of a single argument which is processed by the else clause
'     ' in the Case 1 branch of pvAddorInsert
'         Guard Id.InvalidType, Types.Group.IsAdmin(ipParamOne), i.Location & "pvAddOrInsertTwoParams", Array(TypeName(ipParamOne)), "Admin types cannot be keys '{0}'"
        
'         Select Case True
                    
'             Case Types.Group.IsPrimitive(ipParamOne) 'Imlemented
        
'                 ' for two parameters when ipParamOne is a primitive
'                 ' a Key:Value pair is being presented
'                 InputItemsAsIterableIterable Array(ipParamOne), Array(ipParamTwo), ipStartIndex
            
                
'             Case Arrays.IsTableArray(ipParamOne)
                
'                 CaseTwoParamsAsTableArrayvsParamTwo ipParamOne, ipParamTwo, ipStartIndex
            
            
'             Case Types.Group.IsIterableKeysByEnum(ipParamOne) ' Implemented
            
'                 CaseTwoParamsAsIterableKeysByEnumvsParamTwo ipParamOne, ipParamTwo, ipStartIndex
                
            
'             Case Types.Group.IsIterableItemsByEnum(ipParamOne) 'Implemented
            
'                 CaseTwoParamsAsIterableItemsByEnumVsParamTwo ipParamOne, ipParamTwo, ipStartIndex
        
            
'             Case Else
            
'                 Guard Id.InvalidType, True, i.Location & "pvAddOrInsertTwoParams", TypeName(ipParamOne)

            
'         End Select
    
'     End Sub

    
'     '@Description("Adds the items of ipArgs as individual items")
'     Friend Sub InputItemsThreeOrMoreParams(ByVal ipArgs As Variant, ByVal ipStartIndex As Long)
' Attribute InputItemsThreeOrMoreParams.VB_Description = "Adds the items of ipArgs as individual items"
        
'         If s.FirstUse Then InjectAutoKey
        
'         InputItemsAsIterableIterable GetAutoKeySequence(UBound(ipArgs) - LBound(ipArgs) + 1), ipArgs, ipStartIndex
        
'     End Sub


'     Public Sub InputItemsAsIterableIterable(ByVal ipIterableKeys As Variant, ByVal ipIterableItems As Variant, ByVal ipStartIndex As Long)

'         If ipStartIndex = -1 Then
        
'             s.Keys.AddRange ipIterableKeys
'             s.Items.AddRange ipIterableItems
            
'         Else
        
'             s.Keys.InsertRange ipStartIndex, ipIterableKeys
'             s.Items.InsertRange ipStartIndex, ipIterableItems
            
'         End If
        
'     End Sub

'     Friend Sub InputItemsAsTableArray(ByVal ipTablearray As Variant, ByVal ipAction As Action, ByVal ipStartIndex As Long)
'         'This method has significant reliance of arrays.trytolystoflysts to preprocess the table
        
'         'If ipAction Is Not a member of the TabletoLystAction enum,
'         'then the parameter pair Is treated as nonsensical
'         Guard _
'             NotEnumerationMember, _
'             Enums.TableToLystActions.LacksMember(ipAction), _
'             i.Location + "pvpvAddOrInsertTableArray", _
'             Array(TypeName(Enums.TableToLystActions))
        
'         'convert the table to a lyst of lysts
'         Dim myPreKvp As Lyst
'         Set myPreKvp = Enums.TableToLystActions.Exec(ipAction, ipTablearray)
        
'         Dim myPreKvpKeys As Lyst
'         Dim myPreKvpItems As Lyst
        
'         If myPreKvp.Count = 1 Then
            
'                 ' myPreKvp is a single lyst of rows or columns
'                 Set myPreKvpKeys = s.AutoKey.GetKeySequence(myPreKvp.First.Count)
'                 Set myPreKvpItems = myPreKvp
                
                
'         Else
            
'                 ' myPreKvp contains two lysts.
'                 ' The first is a list of first row/column items
'                 ' the second is a list of the rows/columns adjusted as per the split/copy first item requirement
'                 Set myPreKvpKeys = myPreKvp.First
'                 Set myPreKvpItems = myPreKvp.Item(1)
                
                
'         End If
        
'         Dim myIndex As Long
'         For myIndex = 0 To myPreKvpKeys.LastIndex
            
'             InputItemsTwoParams myPreKvpKeys.Item(myIndex), Me.Deb.Add(myPreKvpItems.Item(myIndex)), ipStartIndex
            
'         Next
                    
'     End Sub

'     Friend Sub AdjustAllItems(ByVal ipAdjustAmount As Variant)
        
'         With s.Items
        
'             Dim myIndex As Long
'             For myIndex = 0 To LastIndex
                
'                 .Item(myIndex) = .Item(myIndex) + ipAdjustAmount
                
'             Next
        
'         End With
        
'     End Sub
'     ' Private Sub pvCase2Arg0IsPrimitive(ByVal ipArgs As Variant, ByVal ipIndex As Long)

'     '     ' If two parameters and ipParamOne is a primitive we are adding
'     '     ' a Key:Value pair
        
'     '     pvAddOrInsertIterableIterable Array(ipArgs(0)), Array(ipArgs(1)), ipIndex
                            
'     ' End Sub
    
'     Public Property Get AutoKey() As IAutoKey
'         Set AutoKey = s.AutoKey
'     End Property
    
'     ' Public Property Set AutoKey(ByVal ipAutoKey As IAutoKey)
        
'     '     Guard DisallowedOverwrite, Types.IsNotSameInstance(s.AutoKey, Nothing), i.Location & "Set pvAutoKey"
'     '     Set s.AutoKey = ipAutoKey
        
'     ' End Property

'     Private Sub CaseTwoParamsAsIterableKeysByEnumvsParamTwo(ByVal ipParamOne As Variant, ByVal ipParamTwo As Variant, ByVal ipStartIndex As Long)

'         Select Case True
                                      
'             Case Types.Group.IsPrimitive(ipParamTwo), Types.Group.IsAdmin(ipParamTwo)
            
'                 'add row first items vs primitive in ipParamTwo
'                 InputItemsAsIterableIterable _
'                     ipParamOne.Keys, _
'                     Ranges.GetConstSeries(Types.Iterable.Count(ipParamOne), ipParamTwo), _
'                     ipStartIndex
             
                
'             Case Types.Group.IsIterableItemsByEnum(ipParamTwo)
            
'                 ' arg0 first value of rows pairs with  arg1 item
'                 InputItemsAsIterableIterable _
'                     ipParamOne.Keys, _
'                     ipParamTwo, _
'                     ipStartIndex
                
                 
'             Case Arrays.IsTableArray(ipParamTwo)
            
'                 'Pair arg0 firstvalues with split first rank values
'                 Dim myArg1RankLysts As Lyst
'                 Set myArg1RankLysts = Arrays.ToLystOfRanksAsLyst(ipParamTwo, Enums.TableToLystActions.AsEnum(RankIsRowFirstItemActionIsSplit))
        
'                 InputItemsAsIterableIterable _
'                     ipParamOne.Keys, _
'                     myArg1RankLysts.Item(Enums.TableToLystActions..RankLysts), _
'                     ipStartIndex
                
                
'             Case Types.Group.IsIterableKeysByEnum(ipParamTwo)
'                 ' first value of arg0 rows with arg1 items
'                 InputItemsAsIterableIterable _
'                 ipParamOne.Keys, _
'                 ipParamTwo.Items, _
'                 ipStartIndex
                
                
'             Case Else
'                 'todo we can't just add object as each item will point to the same object
'                 ' so rethink this code
'                 InputItemsAsIterableIterable _
'                     ipParamOne, _
'                     Ranges.GetConstSeries(TypesIterables.Count(ipParamOne), ipParamTwo), _
'                     ipStartIndex
'                 ' CustomErrors.Throw _
'                 '     InvalidType, _
'                 '     i.Location & "pvCase2TableArrayvsArg1", _
'                 '     Fmt.Txt(Enums.TableToLystActions.ToString(GuardClause.IsInvalidType), "Iterable", TypeName(ipParamTwo))
                
                    
'         End Select
        
'     End Sub


'     Private Sub CaseTwoParamsAsTableArrayvsParamTwo(ByVal iparray As Variant, ByVal ipTableToLystAction As Variant, ByVal ipStartIndex As Long)
        
'         'For use when ipParamTwo is not a primitive number
'         Dim myArg0RankLysts As Lyst
'         Set myArg0RankLysts = Arrays.ToLystOfRanksAsLyst(iparray, Enums.TableToLystActions.AsEnum(RankIsRowFirstItemActionIsSplit))
        
'         Select Case True
                            
'             Case Enums.TableToLystActions.HoldsMember(ipTableToLystAction)
            
'                 'Add table according to TableLystAction enum in ipParamTwo
'                 InputItemsAsTableArray iparray, ipTableToLystAction, ipStartIndex
                
            
'             Case Types.Group.IsPrimitive(ipTableToLystAction), Types.Group.IsAdmin(ipTableToLystAction)
            
'                 'add row first items vs primitive in ipParamTwo
'                 InputItemsAsIterableIterable _
'                     myArg0RankLysts.Item(Enums.TableToLystActions.FirstItems), _
'                     Ranges.GetConstSeries(myArg0RankLysts.Count, ipTableToLystAction), _
'                     ipStartIndex
             
                
'             Case Types.Group.IsIterableItemsByEnum(ipTableToLystAction)
            
'                 ' arg0 first value of rows pairs with  arg1 item
'                 InputItemsAsIterableIterable _
'                     myArg0RankLysts.Item(Enums.TableToLystActions.FirstItems), _
'                     ipTableToLystAction, _
'                     ipStartIndex
                
                 
'             Case Arrays.IsTableArray(ipTableToLystAction)
            
'                 'Pair arg0 firstvalues with split first rank values
'                 Dim myArg1RankLysts As Lyst
'                 Set myArg1RankLysts = Arrays.ToLystOfRanksAsLyst(ipTableToLystAction, Enums.TableToLystActions.AsEnum(RankIsRowFirstItemActionIsSplit))
        
'                 InputItemsAsIterableIterable _
'                     myArg0RankLysts.Item(Enums.TableToLystActions.FirstItems), _
'                     myArg1RankLysts.Item(Enums.TableToLystActions.RankLysts), _
'                     ipStartIndex
                
                
'             Case Types.Group.IsIterableKeysByEnum(ipTableToLystAction)
'                 ' first value of arg0 rows with arg1 items
'                 InputItemsAsIterableIterable _
'                 myArg0RankLysts.Item(Enums.TableToLystActions.FirstItems), _
'                 ipTableToLystAction.Items, _
'                 ipStartIndex
                
                
'             Case Else
'                 'todo we can't just add object as each item will point to the same object
'                 ' so rethink this code
'                 'Assume we have a. n. other object
        
'                 InputItemsAsIterableIterable _
'                 myArg0RankLysts.Item(Enums.TableToLystActions.FirstItems), _
'                 Ranges.GetConstSeries(myArg0RankLysts.Count, ipTableToLystAction), _
'                 ipStartIndex
'                 ' CustomErrors.Throw _
'                 '     InvalidType, _
'                 '     i.Location & "pvCase2TableArrayvsArg1", _
'                 '     Fmt.Txt(Enums.TableToLystActions.ToString(GuardClause.IsInvalidType), "Iterable", TypeName(ipParamTwo))
                
                    
'         End Select
        
'     End Sub

    
'     Private Sub CaseTwoParamsAsIterableItemsByEnumVsParamTwo(ByVal ipParamOne As Variant, ByVal ipParamTwo As Variant, ByVal ipStartIndex As Long)
        
'         Select Case True
                            
'             ' Case Types.Group.IsNumber(ipParamTwo)
            
'             '     'Add table according to TableLystAction enum in ipParamTwo
'             '     pvAddOrInsertIterableIterable _
'             '         ipParamOne, _
'             '         Ranges.GetConstSeries(Types.Iterable.GetSize(ipParamOne), ipParamTwo), _
'             '         ipStartIndex
                
            
'             Case Types.Group.IsPrimitive(ipParamTwo), Types.Group.IsAdmin(ipParamTwo)
            
'                 'add row first items vs primitive in ipParamTwo
'                 InputItemsAsIterableIterable _
'                     ipParamOne, _
'                     Ranges.GetConstSeries(Types.Iterable.Count(ipParamOne), ipParamTwo), _
'                     ipStartIndex
             
                
'             Case Types.Group.IsIterableItemsByEnum(ipParamTwo)
            
'                 ' arg0 first value of rows pairs with  arg1 item
'                 InputItemsAsIterableIterable _
'                     ipParamOne, _
'                     ipParamTwo, _
'                     ipStartIndex
                
                 
'             Case Arrays.IsTableArray(ipParamTwo)
            
'                 'Pair arg0 firstvalues with split first rank values
'                 Dim myArg1RankLysts As Lyst
'                 Set myArg1RankLysts = Arrays.ToLystOfRanksAsLyst(ipParamTwo, Enums.TableToLystActions.AsEnum(RankIsRowFirstItemActionIsSplit))
        
'                 InputItemsAsIterableIterable _
'                     ipParamOne, _
'                     myArg1RankLysts.Item(Enums.TableToLystActions.RankLysts), _
'                     ipStartIndex
                
                
'             Case Types.Group.IsIterableKeysByEnum(ipParamTwo)
'                 ' first value of arg0 rows with arg1 items
'                 InputItemsAsIterableIterable _
'                 ipParamOne, _
'                 ipParamTwo.Items, _
'                 ipStartIndex
                
                
'             Case Else
'                 'todo we can't just add object as each item will point to the same object
'                 ' so rethink this code
'                 ' A. n. other object
'                 InputItemsAsIterableIterable _
'                     ipParamOne, _
'                     Ranges.GetConstSeries(TypesIterables.Count(ipParamOne), ipParamTwo), _
'                     ipStartIndex
                
                    
'         End Select
        
'     End Sub



'     ' Private Sub pvAddPairOfIterables(ByVal ipKeysList As VBAlib.Lyst, ByVal ipValuesList As VBAlib.Lyst)

'     '     s.Logger.Push "pvAddPairs"
        
'     '     If ipKeysList.Count <> ipValuesList.Count Then
        
'     '         pvReport IterableSizeMismatch, ipKeysList.Count, ipValuesList.Count
'     '         Exit Sub
            
'     '     End If
        
'     '     If s.FirstUse Then
        
'     '         pvInitialiseAutoKey ipKeysList(0)
        
'     '     ElseIf Not VBA.IsEmpty(ipKeysList(0)) Then
        
'     '         If Types.IsNotSameType(s.AutoKey.FirstKey, ipKeysList(0)) Then
        
'     '             pvReport KeyTypeMismatch, s.AutoKey.FirstKeyType, TypeName(ipKeysList(0))
'     '             Exit Sub
                
'     '         End If
            
'     '     End If

'     '     ' Use an index as we are iterating two arraylists
'     '     Dim myIndex As Long
        
'     '     'Debug.Print Iterables.GetSize(ipKeysList)
'     '     For myIndex = 0 To ipKeysList.Count - 1
        
'     '         If VBA.IsEmpty(ipKeysList.Item(myIndex)) Then
        
'     '             pvDoAdd s.AutoKey.GetNextKey, ipValuesList(myIndex)
                
'     '         Else
            
'     '             pvDoAdd ipKeysList(myIndex), ipValuesList(myIndex)
            
'     '         End If
        
'     '     Next
        
'         'Adding pairs does not use the autokey
'         ' the to ensure continuity the autokey.currentkey is set
'         ' to the last key added so that the next autokey
'         ' requested will be the next in sequence from the
'     '     ' keys used in the aded pairs.
'     '     s.AutoKey.CurrentKey = s.Keys.Item(s.Keys.Count - 1)
        
'     '     s.Logger.Pop
        
'     ' End Sub

            
'     ' Private Sub pvAddOrInsertTableArray(ByVal ipTable As Variant, Optional ByVal ipEnum As Long = -1, Optional ByVal ipStartIndex As Long = -1)

'     '     If ipEnum = Then ipEnum = Enums.TableArrayKeys(RankIsRowSplitFirstItem)
'     '     s.Logger.Push "pvAddOrInsertTableArray"
    
        
'     '     If s.FirstUse Then
        
'     '         pvInitialiseAutoKey myTable.Alpha
        
'     '     ElseIf Types.IsNotSameType(s.AutoKey.FirstKeyType, myTable.Alpha) Then
        
'     '         pvReport KeyTypeMismatch, s.AutoKey.FirstKeyType, myTable.Alpha
'     '         Exit Sub
        
'     '     End If
        
        
        
'     '     Select Case ipKeysElement
        
'     '         Case Orientation.Col1
            
'     '             pvAddTableArrayCopyByColumnSeparateKeys myTable
                
'     '         Case Orientation.RankIsColumnCopyFirstItem
            
'     '             pvAddTableArrayCopyByColCopyKeys myTable
                
'     '         Case Orientation.Row1
            
'     '             pvAddTableArrayCopyByRowSeparateKeys myTable
                
'     '         Case Orientation.CopyRow1
            
'     '             pvAddTableArrayCopyByRowCopyKeys myTable
                
'     '         Case Else
            
'     '             pvReport InvalidTableKeysEnum, ipKeysElement
                
'     '     End Select

'     '    s.Logger.Pop
        
'     ' End Sub


'     Friend Sub AdjustByIndex(ByVal ipIndexes As Variant, ByVal ipAmount As Single)
      
'         If ipAmount = 0 Then Exit Sub
            
'         Dim myLocation As String
'         myLocation = i.Location & "Dec"
'         Guard NullReference, Types.IsNotSameInstance(s.Keys, Nothing), myLocation
'         Guard InvalidType, Types.Group.IsNotNumber(ipAmount), myLocation, Array("Number", TypeName(ipAmount), "ipDecrement")
'         Guard InvalidType, Types.Group.IsNotNumber(s.Items.First), myLocation, Array("Number", TypeName(s.Items.First), "s.values")
        
'         If VBA.IsEmpty(ipIndexes) Then
            
'             AdjustbyKey s.Keys, ipAmount
'             Exit Sub
            
'         End If
    
'        ' Guard InvalidType, Types.IsTypeByName(Types.Name.OfLong, ipIndexes), myLocation, Array("Long", TypeName(s.Values.First), "ipIndexes")
        
'         Dim myIndexes As Lyst
'         Set myIndexes = Types.Iterable.ToLyst(ipIndexes)
'         Dim myIndex As Variant
'         For Each myIndex In ipIndexes

'             ' Ignore any index outside current bounds
'             If myIndex > -1 And myIndex < s.Keys.Count Then
                
'                 ' preserve the type in s.values
'                 ' we can use vartype as we are only operating on numbers
'                 Dim myType As VbVarType
'                 myType = VarType(s.Items.Item(myIndex))
'                 s.Items.Item(myIndex) = Types.ToVarTypePrimitive(myType, s.Items.Item(myIndex) + ipAmount)
                
'             End If
            
'         Next
        
             
'     End Sub


'     '@Description("Common code for IncByKey and DecByKey")
'     Friend Sub AdjustbyKey(ByVal ipKeys As Variant, ByVal ipAmount As Single)
' Attribute AdjustbyKey.VB_Description = "Common code for IncByKey and DecByKey"
    
'         If ipAmount = 0 Then Exit Sub
'         If s.Keys Is Nothing Then Exit Sub
            
'         Dim myLocation As String
'         myLocation = i.Location & "Dec"
            
'         Guard InvalidType, Types.Group.IsNotNumber(ipAmount), myLocation, Array("Number", TypeName(ipAmount), "ipDecrement")
'         Guard InvalidType, Types.Group.IsNotNumber(s.Items.First), myLocation, Array("Number", TypeName(s.Items.First), "s.values")
        
'         Dim myKeys As Lyst
'         If Types.Iterable.HasNoItems(ipKeys) Then
            
'             Set myKeys = s.Keys
            
'         ElseIf Types.Group.IsPrimitive(ipKeys) Then
            
'             Set myKeys = Types.Iterable.ToLyst(ipKeys)
                
'         ElseIf VBA.IsArray(ipKeys) Then
            
'             Set myKeys = Types.Iterable.ToLyst(ipKeys)
            
'         Else
            
'             Guard Id.IsNotIterable, Types.Group.IsNotIterable(ipKeys), myLocation
'             Set myKeys = ipKeys
            
'         End If

'         Guard InvalidType, Types.IsNotSameType(s.AutoKey.FirstKey, myKeys(0)), myLocation, Array(s.AutoKey.FirstKeyType, TypeName(myKeys(0)), "ipKeys")
'         Dim myItem As Variant
'         For Each myItem In myKeys

'             ' We choose to ignore any key that is not in s.keys
'             If s.Keys.HoldsItem(myItem) Then
                
'                 Dim myIndex As Long
'                 myIndex = s.Keys.IndexOf(myItem)
                
'                 ' preserve the type in s.values
'                 ' we can use vartype as we are only operating on numbers
'                 Dim myType As VbVarType
'                 myType = VarType(s.Items.Item(myIndex))
'                 s.Items.Item(myIndex) = Types.ToVarTypePrimitive(myType, s.Items.Item(myIndex) + ipAmount)
                
'             End If
            
'         Next
            
'     End Sub


'     ' Private Sub pvDoAdd(ByVal ipKey As Variant, ByVal ipValue As Variant)

'     '     s.Logger.Push "pvDoAdd"
'     '     If s.Keys.HoldsValue(ipKey) Then
        
'     '         pvReport KeyExists, ipKey
'     '         Exit Sub
            
'     '     End If
        
'     '     s.Keys.Add ipKey
'     '     s.Values.Add ipValue
            
'     ' End Sub


'     ' Private Sub pvDoInsert(ByVal ipIndex As Long, ByVal ipKey As Variant, ByVal ipValue As Variant)

'     '     If s.Keys.HoldsValue(ipKey) Then
        
'     '         pvReport "pvDoInsert", KeyExists, ipKey.peek
'     '         Exit Sub
            
'     '     End If
        
'     '     s.Keys.InsertAt ipIndex, ipKey
'     '     s.Values.InsertAt ipIndex, ipValue
            
'     ' End Sub


'     '@Ignore EmptyMethod
'     Private Sub DoNothing()

'     End Sub
    
'     ' VBA uses (col by row) for 2d arrays
'     ' using excel
'     '   Range("a1:e1") gives variant(1 to 1,1 to 5) i.e. 1 row
'     '   Range("A2:A5") gives variant(1 to 4,1 to 1) i.e. 1 column

'     ' Private Sub pvAddTableArrayCopyByColCopyKeys(ByVal ipTable As Variant)

'     '     Dim myTableKvp As Kvp
'     '     Set myTableKvp = Kvp.Deb
        
'     '     Dim myCol As Variant
'     '     For Each myCol In ipTable.Columns
        
'     '         myTableKvp.Add myCol.Item(0), Kvp.Deb.Add(myCol)
            
'     '     Next
        
'     '     Me.Add myTableKvp
        
'     ' End Sub


'     ' Private Sub pvAddTableArrayCopyByRowCopyKeys(ByVal ipTable As Variant)

'     '     Dim myTableKvp As Kvp
'     '     Set myTableKvp = Kvp.Deb
        
'     '     Dim myRows As VBAlib.Lyst
'     '     Set myRows = ipTable.Rows
'     '     Dim myRow As Variant
'     '     For Each myRow In myRows
        
'     '         Dim myKey As Collection
'     '         Set myKey = New Collection
'     '         myKey.Add myRow.Item(0)
            
'     '         myTableKvp.Add myKey.Item(1), Kvp.Deb.Add(myRow)
            
'     '     Next
        
'     '     Me.Add myTableKvp
            
'     ' End Sub

'     ' Private Sub pvAddTableArrayCopyByRowSeparateKeys(ByVal ipTable As Variant)

'     '     Dim myTableKvp As Kvp
'     '     Set myTableKvp = Kvp.Deb
        
'     '     Dim myRow As Variant
'     '     For Each myRow In ipTable.Rows
        
'     '         ' the following jiggery pokery is required bycause operations on
'     '         ' an arraylist do not return a reference to self thus
'     '         ' properties of arraylists cannot be chained.
'     '         Dim myKey As Collection
'     '         Set myKey = New Collection
'     '         myKey.Add myRow.Item(0)
            
'     '         myRow.RemoveAt 0
'     '         myTableKvp.Add myKey.Item(1), Kvp.Deb.Add(myRow)
            
'     '     Next
        
'     '     Me.Add myTableKvp
        
'     ' End Sub

'     ' Private Sub pvAddTableArrayCopyByColumnSeparateKeys(ByVal ipTable As Variant)

'     '     Dim myTableKvp As Kvp
'     '     Set myTableKvp = Kvp.Deb
        
'     '     Dim myCol As Variant
'     '     For Each myCol In ipTable.Columns
        
'     '         ' the following jiggery pokery is required bycause operations on
'     '         ' an arraylist do not return a reference to self thus
'     '         ' properties of arraylists cannot be chained.
'     '         Dim myKey As Collection
'     '         Set myKey = New Collection
'     '         myKey.Add myCol.Item(0)
        
'     '         myCol.RemoveAt 0
'     '         myTableKvp.Add myKey.Item(1), Kvp.Deb.Add(myCol)
            
'     '     Next
        
'     '     Me.Add myTableKvp
        
'     ' End Sub


'     Friend Function GetAutoKeySequence(ByVal ipCount As Long) As Lyst
        
'         Dim myLyst As Lyst
'         Set myLyst = Lyst.Deb
        
'         Dim myCount As Long
'         For myCount = 1 To ipCount
        
'             myLyst.Add s.AutoKey.GetNextKey
            
'         Next
        
'         Set GetAutoKeySequence = myLyst
            
'     End Function


'     Private Function pvGetStringKeys() As ArrayList

'         Dim myKeys As ArrayList
'         Set myKeys = New ArrayList

'         Dim myItem As Variant
'         For Each myItem In s.Keys

'             myKeys.Add CStr(myItem)

'         Next

'         Set pvGetStringKeys = myKeys

'     End Function


'     Friend Sub InjectAutoKey _
'     ( _
'         Optional ByVal ipKey As Variant, _
'         Optional ByVal ipStringKeyAllowedChars As String = vbNullString, _
'         Optional ByVal ipArrayKeyAllowedKeys As Lyst _
'     )
        
'         Guard _
'             Id.InvalidType, _
'             VBA.IsArray(ipKey), _
'             i.Location & "InjectAutoKey", _
'             ipAltMessage:="Keys cannot be an array"
            
'         Select Case True
            
'             Case Types.IsNotMissing(ipArrayKeyAllowedKeys)
            
'                 SetAutoKeyToAutoKeyByIndex ipArrayKeyAllowedKeys, ipKey
                
                
'             Case Types.IsNotMissing(ipStringKeyAllowedChars), Types.IsString(ipKey)
             
'                 SetAutoKeyToAutoKeyByString ipKey, ipStringKeyAllowedChars
                
            
'             Case Types.Group.IsNumber(ipKey)
       
'                 SetAutoKeyToAutoKeyByNumber ipKey
                
                
'         End Select
        
'     End Sub


'     ' Private Sub pvInsertIterable(ByVal ipIndex As Long, ByVal ipIterable As Variant)

'     '     Dim myIndex As Long
'     '     myIndex = ipIndex
'     '     s.Logger.Push "InsertIterable"
        
'     '     If s.FirstUse Then pvInitialiseAutoKey 0&
        
'     '     Dim myValue As Variant
'     '     For Each myValue In ipIterable
        
'     '         pvDoInsert myIndex, s.AutoKey.GetNextKey, myValue
'     '         myIndex = myIndex + 1
            
'     '     Next
        
        
'     '     s.Logger.Pop
        
'     ' End Sub
            
            
'     ' Private Sub pvInsertPairOfIterables(ByVal ipIndex As Long, ByVal ipKeysList As VBAlib.Lyst, ByVal ipValuesList As VBAlib.Lyst)
    
'     '     s.Logger.Push "Private InsertPairs"
        
'     '     ' We have two inputs that will be iterated in a for each loop
'     '     ' to avoid having to determin lbound and ubound if either or
'     '     ' both iterables are an array its simpler to convert both inputs
'     '     ' to an arraylist
        
'     ' '    Dim myKeys As ArrayList
'     ' '    Set myKeys = Iterables.ToLyst(ipKeysIterable)
'     ' '
'     ' '    Dim myValues As ArrayList
'     ' '    Set myValues = Iterables.ToLyst(ipValuesIterable)
        
'     ' '    If Not Arrays.Is1D(ipKeysIterable) Then
'     ' '
'     ' '        pvReport OneDimensionOnly
'     ' '        Exit Sub
'     ' '
'     ' '    End If
'     ' '
'     ' '    If Not Arrays.Is1D(ipValuesIterable) Then
'     ' '
'     ' '        pvReport OneDimensionOnly
'     ' '        Exit Sub
'     ' '
'     ' '    End If
        
'     '     If ipKeysList.Count <> ipValuesList.Count Then
        
'     '         pvReport IterableSizeMismatch, ipKeysList.Count, ipValuesList.Count
'     '         Exit Sub
            
'     '     End If
        
'     '     If s.FirstUse Then
        
'     '         pvInitialiseAutoKey ipKeysList(0)
        
'     '     ElseIf ipKeysList.Count > 0 And Types.IsNotSameType(s.AutoKey.FirstKeyType, ipKeysList(0)) Then
        
'     '         pvReport KeyTypeMismatch, s.AutoKey.FirstKeyType, TypeName(ipKeysList(0))
'     '         Exit Sub
        
'     '     End If
        
'     '     Dim myIndex As Long
'     '     For myIndex = 0 To ipKeysList.Count - 1
        
'     '         'Dim myKey As Variant
            
'     '         If VBA.IsEmpty(ipKeysList(myIndex)) Then
        
'     '             pvDoInsert ipIndex + myIndex, s.AutoKey.GetNextKey, ipValuesList(myIndex)
                
'     '         Else
            
'     '             pvDoInsert ipIndex + myIndex, ipKeysList(myIndex), ipValuesList(myIndex)
            
'     '         End If
            
'     '     Next
        
'     '     s.Logger.Pop

'     ' End Sub
                
                
'     ' Private Sub pvInsertTable(ByVal ipIndex As Long, ByVal ipTable As Variant, Optional ByVal ipKeysElement As Orientation = Orientation.Row1)

'     '     'todo write code to insrt tables
'     '     s.Logger.Push "Private InsertTable"
        
'     '     If s.FirstUse Then
        
'     '         pvInitialiseAutoKey ipTable(0, 0)
        
'     '     ElseIf Types.IsNotSameType(s.AutoKey.FirstKeyType, ipTable(0, 0)) Then
        
'     '         pvReport KeyTypeMismatch, s.AutoKey.FirstKeyType, TypeName(ipTable(0, 0))
'     '         Exit Sub
        
'     '     End If
        
'     ' End Sub

'     ' Private Sub pvReport(ByVal ipError As KvpError, ParamArray ipArgs() As Variant)

'     '     Dim myMethod As String
'     '     myMethod = s.Logger.Pop
        
'     '     Dim myStack As Variant
'     '     myStack = s.Logger.toarray
        
'     '     If s.ErrorOutPut = ToDebugPrint Then
        
'     '         Debug.Print _
'     '             i.ClassName _
'     '             & Char.Period _
'     '             & myMethod
'     '         Debug.Print _
'     '             Fmt.TxtArr(KvpAid.Item(ipError), CVar(ipArgs)) _
'     '             & vbCrLf _
'     '             & Stringifier.ToString(myStack, vbCrLf, ArrayMarkup.Deb(vbNullString, vbNullString, vbNullString))
            
'     '     Else
        
'     '         Err.Raise _
'     '             i.KvpError, _
'     '             i.ClassName & Char.Period & myMethod, _
'     '             Fmt.TxtxArr(KvpAid.Item(ipError), CVar(ipArgs)) _
'     '                 & vbCrLf _
'     '                 & Stringifier.ToString(myStack, vbCrLf, ArrayMarkup.Deb(vbNullString, vbNullString, vbNullString))
        
'     '     End If
        
'     ' End Sub
